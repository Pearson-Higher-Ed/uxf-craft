(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.scrollIntoView = factory());
}(this, (function () { 'use strict';

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  var isElement = function isElement(el) {
    return el != null && typeof el == 'object' && el.nodeType === 1;
  };

  function hasScrollableSpace(el, axis) {
    if (axis === 'Y') {
      return el.clientHeight < el.scrollHeight;
    }

    if (axis === 'X') {
      return el.clientWidth < el.scrollWidth;
    }

    return false;
  }

  function isScrollable(el) {
    var isScrollableY = hasScrollableSpace(el, 'Y');
    var isScrollableX = hasScrollableSpace(el, 'X');
    return isScrollableY || isScrollableX;
  }

  var alignNearestBlock = function alignNearestBlock(targetStart, targetSize, frame, frameRect) {
    var targetEnd = targetStart + targetSize;
    var elementEdgeA = frame.scrollTop + targetStart;
    var elementEdgeB = frame.scrollTop + targetEnd;
    var scrollingEdgeA = frame.scrollTop;
    var height = frame === document.documentElement ? frame.clientHeight : frameRect.bottom;
    var scrollingEdgeB = document.documentElement ? frame.scrollTop + height : frameRect.bottom;

    if (elementEdgeA < scrollingEdgeA && elementEdgeB > scrollingEdgeB || elementEdgeA > scrollingEdgeA && elementEdgeB < scrollingEdgeB) {
      return 0;
    }

    if (elementEdgeA < scrollingEdgeA && targetSize < height) {
      return targetStart;
    }

    if (elementEdgeB > scrollingEdgeB && targetSize > height) {
      return targetStart;
    }

    if (elementEdgeB > scrollingEdgeB && targetSize < height) {
      return elementEdgeB - scrollingEdgeB;
    }

    if (elementEdgeA < scrollingEdgeA && targetSize > height) {
      return elementEdgeB - scrollingEdgeB;
    }

    return 0;
  };

  var alignNearestInline = function alignNearestInline(targetStart, targetSize, frame, frameRect) {
    var targetEnd = targetStart + targetSize;
    var elementEdgeC = frame.scrollLeft + targetStart;
    var elementEdgeD = frame.scrollLeft + targetEnd;
    var scrollingEdgeC = frame.scrollLeft;
    var scrollingEdgeD = frame.scrollLeft + frame.clientWidth;
    console.log('test');

    if (elementEdgeC < scrollingEdgeC && targetSize < frame.clientWidth || frameRect.left < 0 && targetEnd > frameRect.left && targetSize < frame.clientWidth) {
      return targetStart;
    }

    if (elementEdgeD < scrollingEdgeD && targetSize < frame.clientWidth || frameRect.right > 0 && targetEnd > frameRect.right && targetSize < frame.clientWidth) {
      return targetEnd - frameRect.left - frame.clientWidth;
    }

    return 0;
  };

  var compute = function compute(target, options) {
    if (options === void 0) {
      options = {};
    }

    var _scrollMode$block$inl = _extends({
      scrollMode: 'always',
      block: 'center',
      inline: 'nearest'
    }, options),
        scrollMode = _scrollMode$block$inl.scrollMode,
        block = _scrollMode$block$inl.block,
        inline = _scrollMode$block$inl.inline,
        boundary = _scrollMode$block$inl.boundary;

    if (!isElement(target)) {
      throw new Error('Element is required in scrollIntoViewIfNeeded');
    }

    var targetRect = target.getBoundingClientRect();
    var frames = [];
    var parent;

    while (isElement(parent = target.parentNode) && target !== boundary) {
      if (isScrollable(parent)) {
        frames.push(parent);
      }

      target = parent;
    }

    if (scrollMode === 'if-needed') {
      var isVisible = frames.every(function (frame) {
        var frameRect = frame.getBoundingClientRect();

        if (targetRect.top < frameRect.top) {
          return false;
        }

        if (targetRect.bottom > frameRect.bottom) {
          return false;
        }

        if (frame === document.documentElement && targetRect.bottom > frame.clientHeight) {
          return false;
        }

        return true;
      });

      if (isVisible) {
        return [];
      }
    }

    var targetBlock;
    var targetInline;
    var computations = frames.map(function (frame) {
      var frameRect = frame.getBoundingClientRect();
      var blockScroll = 0;
      var inlineScroll = 0;

      if (block === 'start') {
        if (!targetBlock) {
          targetBlock = targetRect.top;
        }

        if (document.documentElement === frame) {
          blockScroll = frame.scrollTop + targetBlock;
        } else {
          var offset = Math.min(targetBlock - frameRect.top, frame.scrollHeight - frame.clientHeight - frame.scrollTop);
          blockScroll = frame.scrollTop + offset;
          targetBlock -= blockScroll - frame.scrollTop;
        }
      }

      if (block === 'center') {
        if (!targetBlock) {
          targetBlock = targetRect.top + targetRect.height / 2;
        }

        if (document.documentElement === frame) {
          blockScroll = frame.scrollTop + targetBlock - frame.clientHeight / 2;
        } else {
          var _offset = 0 - Math.min(frameRect.top + frameRect.height / 2 - targetBlock, frame.scrollTop);

          blockScroll = frame.scrollTop + _offset;
          targetBlock += frame.scrollTop - blockScroll;
        }
      }

      if (block === 'end') {
        if (!targetBlock) {
          targetBlock = targetRect.bottom;
        }

        if (document.documentElement === frame) {
          blockScroll = frame.scrollTop + targetBlock - frame.clientHeight;
        } else {
          var _offset2 = 0 - Math.min(frameRect.bottom - targetBlock, frame.scrollTop);

          blockScroll = frame.scrollTop + _offset2;
          targetBlock += frame.scrollTop - blockScroll;
        }
      }

      if (block === 'nearest') {
        if (!targetBlock) {
          targetBlock = targetRect.top;
        }

        var _offset3 = alignNearestBlock(targetBlock, targetRect.height, frame, frameRect);

        blockScroll = frame.scrollTop + _offset3;

        if (document.documentElement !== frame) {
          targetBlock -= _offset3;
        }
      }

      if (inline === 'start') {
        if (!targetInline) {
          targetInline = targetRect.left;
        }

        if (document.documentElement === frame) {
          inlineScroll = frame.scrollLeft + targetInline;
        } else {
          var _offset4 = Math.min(targetInline - frameRect.left, frame.scrollLeft - frame.clientLeft - frame.scrollLeft);

          inlineScroll = frame.scrollLeft + _offset4;
          targetInline -= inlineScroll - frame.scrollLeft;
        }
      }

      if (inline === 'center') {
        if (!targetInline) {
          targetInline = targetRect.left + targetRect.width / 2;
        }

        if (document.documentElement === frame) {
          inlineScroll = frame.scrollLeft + targetInline - frame.clientWidth / 2;
        } else {
          var _offset5 = 0 - Math.min(frameRect.left + frameRect.width / 2 - targetInline, frame.scrollLeft);

          inlineScroll = frame.scrollLeft + _offset5;
          targetInline += frame.scrollLeft - inlineScroll;
        }
      }

      if (inline === 'end') {
        if (!targetInline) {
          targetInline = targetRect.right;
        }

        if (document.documentElement === frame) {
          inlineScroll = frame.scrollLeft + targetInline - frame.clientWidth;
        } else {
          var _offset6 = 0 - Math.min(frameRect.right - targetInline, frame.scrollLeft);

          inlineScroll = frame.scrollLeft + _offset6;
          targetInline += frame.scrollLeft - inlineScroll;
        }
      }

      if (inline === 'nearest') {
        if (!targetInline) {
          targetInline = targetRect.left;
        }

        var _offset7 = alignNearestInline(targetInline, targetRect.width, frame, frameRect);

        inlineScroll = frame.scrollLeft + _offset7;

        if (document.documentElement !== frame) {
          targetInline -= _offset7;
        }
      }

      return {
        el: frame,
        top: blockScroll,
        left: inlineScroll
      };
    });
    return computations;
  };

  var index = (function (target, maybeOptions) {
    if (maybeOptions === void 0) {
      maybeOptions = true;
    }

    var options = {};

    if (maybeOptions === true || maybeOptions === null) {
      options = {
        block: 'start',
        inline: 'nearest'
      };
    } else if (maybeOptions === false) {
      options = {
        block: 'end',
        inline: 'nearest'
      };
    } else if (maybeOptions === Object(maybeOptions)) {
      options = Object.keys(maybeOptions).length === 0 ? {
        block: 'start',
        inline: 'nearest'
      } : _extends({
        block: 'center',
        inline: 'nearest'
      }, maybeOptions);
    }

    var _options = options,
        _options$behavior = _options.behavior,
        behavior = _options$behavior === void 0 ? 'auto' : _options$behavior,
        computeOptions = _objectWithoutProperties(_options, ["behavior"]);

    var instructions = compute(target, computeOptions);

    if (typeof behavior == 'function') {
      return behavior(instructions);
    }

    instructions.forEach(function (_ref) {
      var el = _ref.el,
          top = _ref.top,
          left = _ref.left;

      if (el.scroll) {
        el.scroll({
          top: top,
          left: left,
          behavior: behavior
        });
      } else {
        el.scrollTop = top;
        el.scrollLeft = left;
      }
    });
  });

  return index;

})));
